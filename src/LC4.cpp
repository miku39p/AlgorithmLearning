#include "basic.h"
#include "test.h"
#include <climits>
/*
================================================================================
题目：寻找两个有序数组的中位数
Given two sorted arrays nums1 and nums2 of size m and n respectively,
return the median of the two sorted arrays.
================================================================================

示例 1:
  输入: nums1 = [1,3], nums2 = [2]
  输出: 2.00000
  解释: 合并后数组 = [1,2,3]，中位数是 2

示例 2:
  输入: nums1 = [1,2], nums2 = [3,4]
  输出: 2.50000
  解释: 合并后数组 = [1,2,3,4]，中位数是 (2+3)/2 = 2.5

================================================================================
约束条件:
  nums1.length == m
  nums2.length == n
  0 <= m <= 1000
  0 <= n <= 1000
  1 <= m + n <= 2000
  -10^6 <= nums1[i], nums2[i] <= 10^6

要求: 时间复杂度 O(log(m+n))

tags: array binary_search

note: 解题思路详解（必读）
================================================================================

【核心思想】

中位数本质上是"分界线"——它把有序数组分成左右两半。

如果我们能在两个数组之间找到一条"完美分割线"，使得：
  1. 分割线左边的所有元素 ≤ 分割线右边的所有元素
  2. 左边元素个数 = 右边元素个数（或相差1）

那么中位数就是：
  - 偶数长度：(左边最大值 + 右边最小值) / 2
  - 奇数长度：左边最大值（或右边最小值，相同）

【为什么用二分搜索】

直接合并数组需要 O(m+n) 时间，不符合要求。

我们只需要找到一个分割位置，这个位置可以通过二分搜索找到：
  - 在较短的数组上二分，每次 O(1) 判断
  - 每次排除一半的候选位置
  - 总复杂度 O(log(min(m,n)))

【关键技巧】

1. 交换数组：确保 nums1 是较短的数组
   - 减少二分搜索的空间
   - 处理边界情况更简单

2. 分割点表示：
   - 设 i 为 nums1 的分割点索引（分割线在 i 右边）
   - 设 j 为 nums2 的分割点索引
   - 则 nums1 左边有 i 个元素，右边有 m-i 个
   - 则 nums2 左边有 j 个元素，右边有 n-j 个

3. 分割条件：
   - nums1LeftMax ≤ nums2RightMin
   - nums2LeftMax ≤ nums1RightMin
   - 左边总元素数 = 右边总元素数（或相差1）

4. 边界处理（当分割点超出数组边界时）：
   - 如果 i=0，nums1LeftMax = -∞（左边为空）
   - 如果 i=m，nums1RightMin = +∞（右边为空）
   - j 的处理类似

【图解示例】

示例: nums1 = [1,3], nums2 = [2]

我们寻找分割点使得：
  nums1: [1 | 3]      (i=1, 左边=[1], 右边=[3])
  nums2: [  | 2]      (j=1, 左边=[2], 右边=[])

检查:
  nums1LeftMax = 1
  nums1RightMin = 3
  nums2LeftMax = 2
  nums2RightMin = +∞

验证条件:
  nums1LeftMax ≤ nums2RightMin → 1 ≤ +∞ ✓
  nums2LeftMax ≤ nums1RightMin → 2 ≤ 3   ✓

左边总数 = 1+1 = 2，右边总数 = 1+1 = 2，相等
中位数 = (max(1,2) + min(3,+∞)) / 2 = (2 + 3) / 2 = 2.5

但原答案是 2... 等一下，让我重新检查

哦！正确分割应该是：
  nums1: [1,3] → [1,3] 全部在左边
  nums2: [2]   → [2]    全部在右边

不，让我重新思考...

正确理解：
  分割后：左边=[1,2], 右边=[3]
  nums1: [1 | 3]      (i=1)
  nums2: [  | 2]      (j=1) → 不对

正确理解是：
  分割线把两个数组都切成两半
  nums1: [1 | 3]      i=1, 左边=[1], 右边=[3]
  nums2: [2 | ]       j=0, 左边=[], 右边=[2] 也不对

让我重新计算：
  m=2, n=1, 总长度=3, 左边应该有 1 个元素，右边有 2 个元素
  
  设 i=1, 则 j = (m+n+1)/2 - i = (3+1)/2 - 1 = 2 - 1 = 1
  
  nums1: [1 | 3]      i=1
  nums2: [2 | ]       j=1
  
  左边: nums1Left=[1], nums2Left=[2] → [1,2]
  右边: nums1Right=[3], nums2Right=[] → [3]
  
  左边最大值 = max(1,2) = 2
  右边最小值 = min(3, +∞) = 3
  
  因为总长度是奇数，中位数 = 左边最大值 = 2 ✓

================================================================================
*/

// ==============================================================================
// 辅助函数：获取数组的边界值
// 在分割时，如果分割点在数组边界（0 或 数组长度），需要特殊处理
// 我们用 -∞ 和 +∞ 来表示"不存在"的边界值
// ==============================================================================
double getBoundaryValue(const vector<int>& nums, int index, bool isLeft) {
  // index: 分割点索引
  // isLeft: true 表示获取左边界的最大值，false 表示获取右边界的最小值
  
  if (isLeft) {
    // 获取左边的最大值
    // 如果 index <= 0，说明左边为空，返回 -∞（用最小整数值表示）
    // 注意：LeetCode 约束是 -10^6 ~ 10^6，用 INT_MIN 是安全的
    if (index <= 0) {
      return INT_MIN;  // 负无穷大
    }
    // 否则返回分割点前一个元素的值（即左边部分的最后一个元素）
    return nums[index - 1];
  } else {
    // 获取右边的最小值
    // 如果 index >= 数组长度，说明右边为空，返回 +∞（用最大整数值表示）
    if (index >= (int)nums.size()) {
      return INT_MAX;  // 正无穷大
    }
    // 否则返回分割点位置的元素值（即右边部分的第一个元素）
    return nums[index];
  }
}

// ==============================================================================
// 主解函数
// nums1: 第一个有序数组，长度为 m
// nums2: 第二个有序数组，长度为 n
// 返回值：两个数组的中位数
// ==============================================================================
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
  // ==============================================================================
  // 步骤 1：确保 nums1 是较短的数组
  // 原因：
  //   - 二分搜索的时间复杂度是 O(log(min(m,n)))
  //   - 选择较短的数组可以最大化减少搜索空间
  //   - 如果 nums1 比 nums2 长，就交换它们
  // ==============================================================================
  if (nums1.size() > nums2.size()) {
    // 交换两个向量
    // 使用 swap 而不是 nums1 = nums2 是因为 swap 不会发生深拷贝，效率更高
    swap(nums1, nums2);
  }
  
  // 现在 nums1 是较短（或等长）的数组
  int m = nums1.size();  // nums1 的长度
  int n = nums2.size();  // nums2 的长度
  
  // ==============================================================================
  // 步骤 2：计算中位数的位置
  // totalLeft: 左边应该有多少个元素
  // 对于偶数总长度：左边 totalLength/2 个，右边 totalLength/2 个
  // 对于奇数总长度：左边 (totalLength+1)/2 个，右边 (totalLength-1)/2 个
  // 使用 (m+n+1)/2 可以同时覆盖奇数和偶数情况
  // ==============================================================================
  int totalLeft = (m + n + 1) / 2;  // 左边元素总数
  
  // ==============================================================================
  // 步骤 3：在 nums1 上二分搜索找到最佳分割点
  // 分割点 i 的含义：
  //   - nums1[0..i-1] 在分割线左边，共 i 个元素
  //   - nums1[i..m-1] 在分割线右边，共 m-i 个元素
  // 
  // 对应的 j（nums2 的分割点）由公式计算：
  //   - 左边总数 = i + j = totalLeft
  //   - 所以 j = totalLeft - i
  // ==============================================================================
  
  // 搜索范围：
  // low = 0：分割线在最左边，i=0 表示 nums1 全部在右边
  // high = m：分割线在最右边，i=m 表示 nums1 全部在左边
  int low = 0;
  int high = m;
  
  // 循环不变式：
  //   low <= i <= high
  //   分割点一定在这个范围内
  while (low <= high) {
    // i: nums1 的分割点候选值
    // mid = (low + high) / 2，这是典型的二分搜索取中点
    int i = (low + high) / 2;
    
    // j: 根据 i 计算得到的 nums2 的分割点
    // j = totalLeft - i
    int j = totalLeft - i;
    
    // ==============================================================================
    // 步骤 4：获取四个边界值
    // nums1LeftMax   = nums1[i-1]  如果 i > 0，否则 -∞
    // nums1RightMin  = nums1[i]    如果 i < m，否则 +∞
    // nums2LeftMax   = nums2[j-1]  如果 j > 0，否则 -∞
    // nums2RightMin  = nums2[j]    如果 j < n，否则 +∞
    // ==============================================================================
    double nums1LeftMax = getBoundaryValue(nums1, i, true);   // 左边最大值
    double nums1RightMin = getBoundaryValue(nums1, i, false); // 右边最小值
    double nums2LeftMax = getBoundaryValue(nums2, j, true);   // 左边最大值
    double nums2RightMin = getBoundaryValue(nums2, j, false);// 右边最小值
    
    // ==============================================================================
    // 步骤 5：检查分割是否正确
    // 
    // 完美分割的条件：
    //   1. nums1LeftMax ≤ nums2RightMin（nums1左边 ≤ nums2右边）
    //   2. nums2LeftMax ≤ nums1RightMin（nums2左边 ≤ nums1右边）
    // 
    // 如果条件满足，说明找到了正确的分割点
    // 如果 nums1LeftMax > nums2RightMin，说明 nums1 的分割点太靠右，需要向左移
    // 如果 nums2LeftMax > nums1RightMin，说明 nums1 的分割点太靠左，需要向右移
    // ==============================================================================
    
    // 情况 1：nums1 的分割点太靠右了
    // nums1LeftMax > nums2RightMin 表示 nums1 左边有元素比 nums2 右边还大
    // 需要减小 i（让 nums1 左边少一些，右边多一些）
    if (nums1LeftMax > nums2RightMin) {
      // 搜索左半部分
      high = i - 1;
    }
    // 情况 2：nums1 的分割点太靠左了
    // nums2LeftMax > nums1RightMin 表示 nums2 左边有元素比 nums1 右边还大
    // 需要增大 i（让 nums1 左边多一些，右边少一些）
    else if (nums2LeftMax > nums1RightMin) {
      // 搜索右半部分
      low = i + 1;
    }
    // 情况 3：找到了正确的分割点！
    // 两个条件都满足：
    //   nums1LeftMax ≤ nums2RightMin ✓
    //   nums2LeftMax ≤ nums1RightMin ✓
    else {
      // ==============================================================================
      // 步骤 6：计算中位数
      // 
      // 现在我们有了正确的分割，可以计算中位数了：
      //   - 左边最大值 = max(nums1LeftMax, nums2LeftMax)
      //   - 右边最小值 = min(nums1RightMin, nums2RightMin)
      // 
      // 根据总长度是奇数还是偶数：
      //   - 奇数：中位数就是左边最大值（因为左边比右边多一个）
      //   - 偶数：中位数是 (左边最大值 + 右边最小值) / 2
      // ==============================================================================
      
      // 判断总长度是否为偶数
      // 如果 (m + n) % 2 == 0，说明是偶数长度
      if ((m + n) % 2 == 0) {
        // 偶数情况：
        // 中位数 = (左边最大值 + 右边最小值) / 2
        // 注意：两边都可能包含元素，取最大和最小值
        double median = (max(nums1LeftMax, nums2LeftMax) + 
                         min(nums1RightMin, nums2RightMin)) / 2.0;
        return median;
      } else {
        // 奇数情况：
        // 左边比右边多一个元素，所以中位数就是左边最大值
        // 右边最小值其实就是左边最大值的"下一个"，所以左边最大值就是中位数
        double median = max(nums1LeftMax, nums2LeftMax);
        return median;
      }
    }
  }
  
  // ==============================================================================
  // 如果程序执行到这里，说明输入有问题
  // 在理论上，由于约束条件 1 <= m+n <= 2000，应该总能找到解
  // 这里返回一个特殊值表示错误
  // ==============================================================================
  
  // 如果二分搜索没有找到解（理论上不应该发生），返回 -1
  // 这通常意味着输入不满足约束条件
  return -1;
}

// ==============================================================================
// 测试用例
// 使用 test.h 框架注册测试
// ==============================================================================
void registerTests() {
  // ==============================================================================
  // 测试 1：两个数组长度都是奇数，合并后总长度为奇数
  // nums1 = [1,3], nums2 = [2]
  // 合并后 = [1,2,3]，中位数 = 2
  // ==============================================================================
  test_runner.addTest("奇数总长度 [1,3] + [2]", []() {
    vector<int> nums1 = {1, 3};
    vector<int> nums2 = {2};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, 2.0);
  });
  
  // ==============================================================================
  // 测试 2：两个数组长度都是偶数，合并后总长度为偶数
  // nums1 = [1,2], nums2 = [3,4]
  // 合并后 = [1,2,3,4]，中位数 = (2+3)/2 = 2.5
  // ==============================================================================
  test_runner.addTest("偶数总长度 [1,2] + [3,4]", []() {
    vector<int> nums1 = {1, 2};
    vector<int> nums2 = {3, 4};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, 2.5);
  });
  
  // ==============================================================================
  // 测试 3：其中一个数组为空
  // nums1 = [], nums2 = [1]
  // 合并后 = [1]，中位数 = 1
  // ==============================================================================
  test_runner.addTest("一个数组为空 [] + [1]", []() {
    vector<int> nums1 = {};
    vector<int> nums2 = {1};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, 1.0);
  });
  
  // ==============================================================================
  // 测试 4：两个数组都是单个元素
  // nums1 = [1], nums2 = [2]
  // 合并后 = [1,2]，中位数 = 1.5
  // ==============================================================================
  test_runner.addTest("两个单元素数组 [1] + [2]", []() {
    vector<int> nums1 = {1};
    vector<int> nums2 = {2};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, 1.5);
  });
  
  // ==============================================================================
  // 测试 5：负数的情况
  // nums1 = [-5], nums2 = [-3, -1]
  // 合并后 = [-5, -3, -1]，中位数 = -3
  // ==============================================================================
  test_runner.addTest("含负数的数组 [-5] + [-3,-1]", []() {
    vector<int> nums1 = {-5};
    vector<int> nums2 = {-3, -1};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, -3.0);
  });
  
  // ==============================================================================
  // 测试 6：nums1 比 nums2 长
  // nums1 = [1,3,5,7,9], nums2 = [2,4,6,8]
  // 合并后 = [1,2,3,4,5,6,7,8,9]，中位数 = 5
  // ==============================================================================
  test_runner.addTest("nums1更长 [1,3,5,7,9] + [2,4,6,8]", []() {
    vector<int> nums1 = {1, 3, 5, 7, 9};
    vector<int> nums2 = {2, 4, 6, 8};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, 5.0);
  });
  
  // ==============================================================================
  // 测试 7：边界值 - 最小整数值
  // nums1 = [-1000000], nums2 = [1000000]
  // 合并后 = [-1000000, 1000000]，中位数 = 0
  // ==============================================================================
  test_runner.addTest("边界值 -1000000 + 1000000", []() {
    vector<int> nums1 = {-1000000};
    vector<int> nums2 = {1000000};
    double result = findMedianSortedArrays(nums1, nums2);
    EXPECT_EQ(result, 0.0);
  });
}

